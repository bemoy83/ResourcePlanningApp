Implementation Order (First Vertical Slice)
Guiding rule for this order

Define facts â†’ define math â†’ define state â†’ define views

We always implement:

Definitions before behavior

Pure logic before orchestration

Read models after writes exist

Phase 0 â€” Repo scaffolding (very light, 1 sitting)

Goal: Make architectural intent visible before any logic exists.

Do this first

Create folder structure by module:

/modules
  /events
  /work
  /productivity
  /resources
  /schedule


Add:

ARCHITECTURE.md

(optional) MVP.md with the slice definition

ğŸš« No code yet. This prevents â€œwhere should this live?â€ mistakes later.

Phase 1 â€” Events module (foundation, no planning risk)

Why first:
Events define the time boundary. Everything else depends on this, and it has zero planning logic risk.

Implement in this order

Event domain model

Event ID

Name

Start / end date

Status

Pure logic

isValidEventDateRange

calculateEventDurationDays

Persistence

Prisma schema

createEvent

getEvent

API routes

Create event

Fetch event

âœ… Stop here and test:
â€œCan I create an event and retrieve its date range?â€

Phase 2 â€” Work module (static scope, no time logic)

Why second:
Work defines how much work exists, but not when. Still safe.

Implement in this order

Work Category model

ID

Event ID

Name

Estimated effort (hours/FTE)

Pure validation

validateEstimatedEffort

Persistence

Create / update work categories

Query by event

API routes

Add work category

Update estimate

List work for event

âœ… Stop and test:
â€œCan I define work categories with total estimates for an event?â€

Phase 3 â€” Productivity module (pure math only)

Why now:
You want conversions locked in before allocations exist.
Also: zero persistence = very low risk.

Implement in this order

Pure functions only

convertFteToHours

convertHoursToFte

Config source

Hardcoded config or DB-backed (read-only)

ğŸš« No API routes required yet
ğŸš« No state mutation allowed

âœ… Test with unit tests only.

Phase 4 â€” Resources module (capacity as passive input)

Why before Schedule:
Schedule must not own capacity logic. This enforces that separation.

Implement in this order

Resource model

ID

Name

Daily capacity

Availability rules

Pure logic

calculateDailyCapacity

applyAvailabilityConstraints

Stateful orchestration

getResourceCapacity(resourceId, dateRange)

Persistence + API

Create resource

Update capacity

Fetch capacity summary

âœ… Stop and test:
â€œCan I ask: how much capacity exists on a given day?â€

Phase 5 â€” Schedule module (the core, go slow here)

Why last:
This is where all your invariants matter. By now, everything it depends on is frozen.

Implement in this exact order
5.1 Allocation model (no evaluation yet)

Allocation:

ID

Event ID

Work Category ID

Date

Hours (normalized)

5.2 Pure logic first

normalizeAllocationToHours

isAllocationWithinEventRange

aggregateDailyDemand

ğŸš« No persistence yet

5.3 Stateful allocation commands

addAllocation

updateAllocation

removeAllocation

Rules enforced here:

Valid IDs

Within event range

No auto-distribution

5.4 Evaluation (signals only)

calculateOverUnderAllocationIndicator

evaluateSchedule(eventId)

ğŸš« Must not mutate allocations
âœ… May populate read models

5.5 Read models

Daily demand per event

Daily capacity per event

Indicator flags

Phase 6 â€” Minimal UI (only after backend is solid)

Rule:
UI must only reflect what already exists.

Forms for:

Events

Work categories

Resources

Allocations

Table for:

Date | Demand | Capacity | Indicator

ğŸš« No suggestions
ğŸš« No defaults
ğŸš« No auto-fill logic

ğŸ”’ Hard stop rule (important)

After each phase, stop and verify:

Invariants still hold

No module imported anotherâ€™s internals

No evaluation mutates state

If something feels â€œhelpfulâ€, itâ€™s wrong.